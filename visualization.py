# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16lF7iGPrfClMhGSusOZNqDEf5YYjfr0n
"""


import pandas as pd
data = pd.read_excel("/content/socialmedia_survey_data.xlsx")

# Hebrew to English mapping for column headers
hebrew_to_english_headers = {
    'Q12_1': 'Frequency-YouTube',
    'Q12_2': 'Frequency-Facebook',
    'Q12_3': 'Frequency-TikTok',
    'Q12_4': 'Frequency-Twitter',
    'Q12_5': 'Frequency-Instagram',
    'Q12_7': 'Frequency-LinkedIn',
    'Q12_13': 'Frequency-WhatsApp',
    'Q12B_1': 'B-YouTube',
    'Q12B_2': 'B-Facebook',
    'Q12B_3': 'B-TikTok',
    'Q12B_4': 'B-Twitter',
    'Q12B_5': 'B-Instagram',
    'Q12B_7': 'B-LinkedIn',
    'Q12B_13': 'B-WhatsApp',
}


# Hebrew to English mapping for values
hebrew_to_english_values = {
    '专':'Other',
    '专拽|': 'Single',
    '砖|': 'Married',
    '专砖|, 驻专|, |, -专转': 'Divorced/Separated/Widowed/Single Parent',
    '住转': 'Elementary education',
    '注转 专拽转 转专':'Less often',
    '拽转': 'Academic',
    '注-转转 (, 住 )': 'Post-secondary (Technician, Engineer, etc.)',
    '转转': 'Secondary',
    ' 爪注': 'Similar to Average',
    '专 注 爪注': 'Way Above Average',
    '专 转转 爪注': 'Way below Average',
    '转转 爪注': 'below Average',
    '注 爪注': 'Above Average',
    '转砖转 专转': 'Other Responses',
    '专  住专|转 砖':'otherwise or refuses to answer',
    ' - 住专转': 'Jewish - Traditional',
    ' - ': 'Jewish - Secular',
    ' - 转 ': 'Jewish - National Religious',
    ' - 专, 专': 'Jewish - Orthodox',
    '注专': 'Muslim',
    '专': 'Male',
    '砖': 'Female',
    '住` 驻注 砖注': 'Several times a week',
    '': 'Daily',
    ' 砖转砖|转': 'Not Using',
    '住` 驻注 砖': 'Several times a month',
    '砖转砖|转': 'Using',
    '专砖': 'Jerusalem',
    '专': 'Center',
    '转 ': 'Tel Aviv',
    '专': 'North',
    '驻': 'Haifa',
    ' 砖专':'Yehoda and Shomron',
    '爪驻': 'South',
}


# Rename the columns using the corrected mapping
data.rename(columns=hebrew_to_english_headers, inplace=True)

# Replace the values in each column based on the mapping
data.replace(hebrew_to_english_values, inplace=True)

# Display the first few rows to check if the translations were successful
data.head()

# Remove the first row (which was previously used as headers)
data = data.iloc[1:]

# Remove all columns from Q12B_1 to Q12B_17
columns_to_remove = ['Q12_6','Q12_8','Q12_9','Q12_10','Q12_11','Q12_12','Q12_14','Q12_15','Q12_16','Q12_17','Q12B_6','Q12B_8','Q12B_9','Q12B_10','Q12B_11','Q12B_12','Q12B_14','Q12B_15','Q12B_16','Q12B_17']
data.drop(columns=columns_to_remove, inplace=True, errors='ignore')

# Select columns that start with 'B-'
columns_to_rename = [col for col in data.columns if col.startswith('B-')]

# Binary replacement dictionary
binary = {
    'Using': 1,
    'Not Using': 0,
}

# Apply the replacement to the selected columns
for col in columns_to_rename:
    data[col] = data[col].replace(binary)

data.head()

# latest version
import numpy as np
# Set random seed for reproducibility
np.random.seed(42)

# Define age groups and corresponding ranges
age_groups = {
    '18-24': (18, 24),
    '25-30': (25, 30),
    '31-39': (31, 39),
    '40-49': (40, 49),
    '50-64': (50, 64),
    '65+': (65, 80)
}

# Define random age generation function
def random_age(group):
    if group in age_groups:
        return np.random.randint(age_groups[group][0], age_groups[group][1] + 1)
    return np.nan

# Generate random ages for each age group
data['Age_group-num'] = data['Age_group'].map(random_age)

# Define ranges for income categories
income_ranges = {
    'Similar to Average': (5001, 8000),
    'Other Responses': (0, 0),
    'Above Average': (8001, 11000),
    'Way Above Average': (11001, 20000),
    'below Average': (3001, 5000),
    'Way below Average': (1, 3000)
}

# Define random income generation function
def random_income(category):
    if category in income_ranges:
        return np.random.randint(income_ranges[category][0], income_ranges[category][1] + 1)
    return np.nan

# Generate random incomes for each income category
data['Income-num'] = data['Income'].map(random_income)

# Define ranges for frequency categories
frequency_ranges = {
    'Several times a week': (11, 28),
    'Daily': (29, 31),
    'Not Using': (0, 0),
    'Several times a month': (5, 10),
    'Less often': (1, 4)
}

# Define random frequency generation function
def random_frequency(category):
    if category in frequency_ranges:
        return np.random.randint(frequency_ranges[category][0], frequency_ranges[category][1] + 1)
    return np.nan

# Generate random frequencies for Instagram and Facebook usage
data['Frequency-Instagram-num'] = data['Frequency-Instagram'].map(random_frequency)
data['Frequency-Facebook-num'] = data['Frequency-Facebook'].map(random_frequency)
data['Frequency-Twitter-num'] = data['Frequency-Twitter'].map(random_frequency)
data['Frequency-YouTube-num'] = data['Frequency-YouTube'].map(random_frequency)


data.head()

data.to_csv('cleaned_survey_data.csv', index=False)

df = pd.read_csv('cleaned_survey_data.csv')


import numpy as np
# Set random seed for reproducibility
np.random.seed(42)

# Define age groups and corresponding ranges
age_groups = {
    '18-24': (18, 24),
    '25-30': (25, 30),
    '31-39': (31, 39),
    '40-49': (40, 49),
    '50-64': (50, 64),
    '65+': (65, 80)
}

# Define random age generation function
def random_age(group):
    if group in age_groups:
        return np.random.randint(age_groups[group][0], age_groups[group][1] + 1)
    return np.nan

# Generate random ages for each age group
data['Age_group-num'] = data['Age_group'].map(random_age)

# Define ranges for income categories
income_ranges = {
    'Similar to Average': (5001, 8000),
    'Other Responses': (0, 0),
    'Above Average': (8001, 11000),
    'Way Above Average': (11001, 20000),
    'below Average': (3001, 5000),
    'Way below Average': (1, 3000)
}

# Define random income generation function
def random_income(category):
    if category in income_ranges:
        return np.random.randint(income_ranges[category][0], income_ranges[category][1] + 1)
    return np.nan

# Generate random incomes for each income category
data['Income-num'] = data['Income'].map(random_income)

# Define ranges for frequency categories
frequency_ranges = {
    'Several times a week': (11, 28),
    'Daily': (29, 31),
    'Not Using': (0, 0),
    'Several times a month': (5, 10),
    'Less often': (1, 4)
}

# Define random frequency generation function
def random_frequency(category):
    if category in frequency_ranges:
        return np.random.randint(frequency_ranges[category][0], frequency_ranges[category][1] + 1)
    return np.nan

# Generate random frequencies for Instagram and Facebook usage
data['Frequency-Instagram-num'] = data['Frequency-Instagram'].map(random_frequency)
data['Frequency-Facebook-num'] = data['Frequency-Facebook'].map(random_frequency)
data['Frequency-Twitter-num'] = data['Frequency-Twitter'].map(random_frequency)
data['Frequency-YouTube-num'] = data['Frequency-YouTube'].map(random_frequency)
data['Frequency-TikTok-num'] = data['Frequency-TikTok'].map(random_frequency)
data['Frequency-LinkedIn-num'] = data['Frequency-LinkedIn'].map(random_frequency)


data.head()

# best wider version with heatmap
import os
from pyngrok import ngrok, conf

# Set your ngrok auth token
netta_AUTHTOKEN = "2d7lXbWUAlOidUH3bqltEc1B1PA_2QAyhTGBNYSMybfEcompW"

# Set the ngrok auth token
conf.get_default().auth_token = netta_AUTHTOKEN

# Start ngrok tunnel
http_tunnel = ngrok.connect(8501)
print(f"Streamlit app is running on: {http_tunnel.public_url}")

# Write the updated Streamlit app code with the visualization
streamlit_app_code = """
import pandas as pd
import streamlit as st
import plotly.express as px

# # Set page configuration
# st.set_page_config(layout="wide")

# Set page configuration
st.set_page_config(
    page_title="App Usage Analysis",
    page_icon="",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Load the CSV file into a DataFrame
file_path = 'cleaned_survey_data.csv'
df = pd.read_csv(file_path)

# Binary replacement dictionary
binary = {
    'Using': 1,
    'Not Using': 0,
}

# Apply the replacement to the selected columns
columns_to_rename = [col for col in df.columns if col.startswith('B-')]
for col in columns_to_rename:
    df[col] = df[col].replace(binary)

# Streamlit app
st.title('App Usage Analysis')

# Select category for analysis
category = st.selectbox('Select a Category', ['Age_group', 'Gender', 'Income', 'App Usage Frequency'])

# Extract relevant columns for the selected category
if category == 'Age_group':
    category_order = ['18-24', '25-30', '31-39', '40-49', '50-64', '65+']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'App Usage Frequency':
    frequency_columns = [col for col in df.columns if col.startswith('Frequency-')]
    df_long_freq = pd.melt(df, id_vars=['Gender', 'Income'], value_vars=frequency_columns,
                           var_name='AppName', value_name='Frequency')
    df_long_freq['AppName'] = df_long_freq['AppName'].str.replace('Frequency-', '')
    main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
    df_long_freq = df_long_freq[df_long_freq['AppName'].isin(main_apps)]
    df_long_freq = df_long_freq.rename(columns={'Frequency': category})
    df = df_long_freq
    category_order = ['Not Using', 'Less often', 'Several times a month', 'Several times a week', 'Daily']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'Income':
    category_order = ['Way below Average', 'below Average', 'Similar to Average', 'Above Average', 'Way Above Average']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
else:  # Gender
    category_order = df[category].unique()

# Transform the dataset to a long format
if category != 'App Usage Frequency':
    df_long = pd.melt(df, id_vars=[category], value_vars=columns_to_rename,
                      var_name='AppName', value_name='Usage')
    df_long = df_long[df_long['Usage'] == 1]  # Filter only those who are using the app
else:
    df_long = df.copy()

# Clean the 'AppName' column
df_long['AppName'] = df_long['AppName'].str.replace('B-', '')

# Filter to include only main applications
main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
df_long = df_long[df_long['AppName'].isin(main_apps)]

# Calculate the count of users for each app and category
if category != 'App Usage Frequency':
    df_count = df_long.groupby(['AppName', category]).size().reset_index(name='UserCount')
    df_total = df_long.groupby('AppName').size().reset_index(name='TotalUsers')
else:
    df_count = df_long.groupby([category, 'AppName']).size().reset_index(name='Count')
    df_total = df_long.groupby('AppName').size().reset_index(name='Total')

# Merge count and total dataframes
df_percentage = pd.merge(df_count, df_total, on='AppName')
if category != 'App Usage Frequency':
    df_percentage['Percentage'] = (df_percentage['UserCount'] / df_percentage['TotalUsers']) * 100
else:
    df_percentage['Percentage'] = (df_percentage['Count'] / df_percentage['Total']) * 100

# Add total user base by category
df_percentage['TotalUserBase'] = df_percentage.groupby(category)['UserCount' if category != 'App Usage Frequency' else 'Count'].transform('sum')

# Add proportion of total users for each category
df_percentage['Proportion'] = (df_percentage['UserCount' if category != 'App Usage Frequency' else 'Count'] / df_percentage['TotalUserBase']) * 100

# Pivot the data to create a dataframe suitable for a bar chart
df_pivot = df_percentage.pivot(index='AppName', columns=category, values='Percentage').reindex(main_apps)

# Sort the DataFrame by the highest value in any column
df_pivot['max'] = df_pivot.max(axis=1)
df_pivot = df_pivot.sort_values(by='max', ascending=False).drop(columns='max').reset_index()

# Melt the pivot dataframe for plotting
df_melted = df_pivot.melt(id_vars='AppName', var_name=category, value_name='Percentage')

# Calculate additional insights for tooltips
df_insights = df_long.groupby(['AppName', category]).size().reset_index(name='Count')
df_insights = df_insights.merge(df_total.rename(columns={'TotalUsers': 'Total'}), on='AppName')
df_insights['Percentage'] = (df_insights['Count'] / df_insights['Total']) * 100

# Add total user base by category
df_insights['TotalUserBase'] = df_insights.groupby(category)['Count'].transform('sum')

# Add proportion of total users for each category
df_insights['Proportion'] = (df_insights['Count'] / df_insights['TotalUserBase']) * 100

# Merge insights with melted dataframe
df_final = pd.merge(df_melted, df_insights, on=['AppName', category], suffixes=('', '_insights'))

# Define color palettes for the categories
diverging_palette = {
    'Not Using': '#ff7f0e',  # Orange
    'Less often': '#fdae6b',  # Light orange
    'Several times a month': '#d9d9d9',  # Gray
    'Several times a week': '#a6cee3',  # Light blue
    'Daily': '#1f78b4',  # Blue
}

sequential_palette = {
    '18-24': '#e5f5e0',  # Light green
    '25-30': '#c7e9c0',  # Light-medium green
    '31-39': '#a1d99b',  # Medium green
    '40-49': '#74c476',  # Dark-medium green
    '50-64': '#41ab5d',  # Dark green
    '65+': '#238b45'  # Very dark green
}

income_palette = {
    'Way below Average': '#edf8e9',  # Light green
    'below Average': '#bae4b3',  # Light-medium green
    'Similar to Average': '#74c476',  # Medium green
    'Above Average': '#31a354',  # Dark-medium green
    'Way Above Average': '#006d2c'  # Dark green
}

gender_palette = {
    'Male': '#1f77b4',  # Blue
    'Female': '#ff7f0e'  # Pink
}

# Select appropriate color palette based on the category
color_discrete_map = diverging_palette if category == 'App Usage Frequency' else (
    sequential_palette if category == 'Age_group' else (
    income_palette if category == 'Income' else (
    gender_palette if category == 'Gender' else None)))

# Plot the bar chart using Plotly
fig = px.bar(df_final,
             x='AppName', y='Percentage', color=category,
             hover_data={'AppName': False, 'Count': True,
                         'Total': True, 'Percentage': ':.2f',
                         'TotalUserBase': True, 'Proportion': ':.2f'},
             color_discrete_map=color_discrete_map)

# Add percentage labels inside bars and center them within each category color
fig.update_traces(texttemplate='%{y:.2f}%', textposition='inside', insidetextanchor='middle')

fig.update_layout(
    title=f'App Usage by {category}',
    xaxis_title='App Name',
    yaxis_title='Percentage',
    yaxis=dict(showticklabels=True),  # Show y-axis labels
    legend_title_text=category,
    width=1400,  # Set the width of the plot
    height=800,  # Set the height of the plot
    xaxis={'categoryorder': 'total descending'}  # Sort by highest column
)

# Show the plot in Streamlit
st.plotly_chart(fig, use_container_width=True)

# Streamlit app
st.title('App Usage Analysis and Visualizations')

# Section 1: App Selection
st.header('Select Apps for Analysis')

# Dropdowns for selecting two apps
app_options = ['Facebook', 'Instagram', 'YouTube', 'Twitter']
# Place dropdowns for selecting apps side by side
col1, col2 = st.columns(2)

with col1:
    app1 = st.selectbox('Select first app', app_options)

with col2:
    # Filter out the first app from the options for the second dropdown
    app_options_filtered = [app for app in app_options if app != app1]
    app2 = st.selectbox('Select second app', app_options_filtered)

# Filter dataframe for selected apps
selected_apps = [f'Frequency-{app1}-num', f'Frequency-{app2}-num']

# Section 2: Scatter Plots
st.header(f'Scatter Plots of Age vs Income with Frequency for {app1} and {app2}')

# Custom color scale from light to dark
custom_color_scale = [
    [0, "yellow"],
    [1, "darkred"]
]

# Scatter plot for the first app
fig_app1 = px.scatter(
    df,
    x='Age_group-num',
    y='Income-num',
    color=selected_apps[0],
    title=f'{app1} Usage',
    labels={selected_apps[0]: f'{app1} Frequency'},
    color_continuous_scale=custom_color_scale
)

fig_app1.update_layout(
    autosize=False,
    width=700,  # Adjust the width as needed
    height=600  # Adjust the height as needed
)

# Scatter plot for the second app
fig_app2 = px.scatter(
    df,
    x='Age_group-num',
    y='Income-num',
    color=selected_apps[1],
    title=f'{app2} Usage',
    labels={selected_apps[1]: f'{app2} Frequency'},
    color_continuous_scale=custom_color_scale
)

fig_app2.update_layout(
    autosize=False,
    width=700,  # Adjust the width as needed
    height=600  # Adjust the height as needed
)

col1, col2 = st.columns([1, 1])

with col1:
    st.plotly_chart(fig_app1, use_container_width=True)

with col2:
    st.plotly_chart(fig_app2, use_container_width=True)

import streamlit as st
import pandas as pd
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from pyngrok import ngrok, conf
import os


# Section 4: Heatmaps for App Usage by Religion
st.header('Heatmaps for App Usage by Religion')

# Select binary columns for heatmap
binary_columns = [col for col in df.columns if col.startswith('B-')]
binary_columns = [col for col in binary_columns if col.endswith((app1, app2))]

# Add validation to ensure there are enough binary columns
if len(binary_columns) < 2:
    st.error(f"Not enough binary columns found for the selected apps: {app1} and {app2}")
else:
    # Plot heatmaps for each selected app
    col1, col2 = st.columns(2)

    # Clean column names for heatmap
    app1_cleaned = app1.replace('B-', '')
    app2_cleaned = app2.replace('B-', '')

    df.rename(columns={binary_columns[0]: app1_cleaned, binary_columns[1]: app2_cleaned}, inplace=True)

    # Heatmap for the first app
    heatmap_data_app1 = pd.crosstab(df['Religion'], df[app1_cleaned])
    heatmap_data_app1.columns = ['Not Using', 'Using']
    fig1, ax1 = plt.subplots(figsize=(8, 6))
    sns.heatmap(heatmap_data_app1, annot=True, fmt='d', cmap='Blues', ax=ax1)
    ax1.set_title(f'Heatmap for {app1_cleaned} Usage by Religion')

    # Heatmap for the second app
    heatmap_data_app2 = pd.crosstab(df['Religion'], df[app2_cleaned])
    heatmap_data_app2.columns = ['Not Using', 'Using']
    fig2, ax2 = plt.subplots(figsize=(8, 6))
    sns.heatmap(heatmap_data_app2, annot=True, fmt='d', cmap='Blues', ax=ax2)
    ax2.set_title(f'Heatmap for {app2_cleaned} Usage by Religion')

    with col1:
        st.pyplot(fig1)
    with col2:
        st.pyplot(fig2)

"""

with open("streamlit_app.py", "w") as f:
    f.write(streamlit_app_code)

# Run the Streamlit app
os.system('streamlit run streamlit_app.py --server.port 8501')

import os
from pyngrok import ngrok, conf

# Set your ngrok auth token
netta_AUTHTOKEN = "2d7lXbWUAlOidUH3bqltEc1B1PA_2QAyhTGBNYSMybfEcompW"

# Set the ngrok auth token
conf.get_default().auth_token = netta_AUTHTOKEN

# Start ngrok tunnel
http_tunnel = ngrok.connect(8501)
print(f"Streamlit app is running on: {http_tunnel.public_url}")

# Write the updated Streamlit app code with the visualization
streamlit_app_code = """
import pandas as pd
import streamlit as st
import plotly.express as px

# Load the CSV file into a DataFrame
file_path = 'cleaned_survey_data.csv'
df = pd.read_csv(file_path)

# Binary replacement dictionary
binary = {
    'Using': 1,
    'Not Using': 0,
}

# Apply the replacement to the selected columns
columns_to_rename = [col for col in df.columns if col.startswith('B-')]
for col in columns_to_rename:
    df[col] = df[col].replace(binary)

# Streamlit app
st.title('App Usage Analysis')

# Select category for analysis
category = st.selectbox('Select a Category', ['Gender', 'Income', 'App Usage Frequency', 'Age_group'])

# Extract relevant columns for the selected category
if category == 'Age_group':
    category_order = ['18-24', '25-30', '31-39', '40-49', '50-64', '65+']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'App Usage Frequency':
    frequency_columns = [col for col in df.columns if col.startswith('Frequency-')]
    df_long_freq = pd.melt(df, id_vars=['Gender', 'Income', 'Age_group'], value_vars=frequency_columns,
                           var_name='AppName', value_name='Frequency')
    df_long_freq['AppName'] = df_long_freq['AppName'].str.replace('Frequency-', '')
    main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
    df_long_freq = df_long_freq[df_long_freq['AppName'].isin(main_apps)]
    df_long_freq = df_long_freq.rename(columns={'Frequency': category})
    df = df_long_freq
    category_order = ['Not Using', 'Less often', 'Several times a month', 'Several times a week', 'Daily']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'Income':
    category_order = ['High', 'Above Average', 'Average', 'Below Average', 'Low']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
else:
    category_order = df[category].unique()

# Transform the dataset to a long format
if category != 'App Usage Frequency':
    df_long = pd.melt(df, id_vars=[category], value_vars=columns_to_rename,
                      var_name='AppName', value_name='Usage')
    df_long = df_long[df_long['Usage'] == 1]  # Filter only those who are using the app
else:
    df_long = df.copy()

# Clean the 'AppName' column
df_long['AppName'] = df_long['AppName'].str.replace('B-', '')

# Filter to include only main applications
main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
df_long = df_long[df_long['AppName'].isin(main_apps)]

# Calculate the count of users for each app and category
if category != 'App Usage Frequency':
    df_count = df_long.groupby(['AppName', category]).size().reset_index(name='UserCount')
    df_total = df_long.groupby('AppName').size().reset_index(name='TotalUsers')
else:
    df_count = df_long.groupby([category, 'AppName']).size().reset_index(name='Count')
    df_total = df_long.groupby('AppName').size().reset_index(name='Total')

# Merge count and total dataframes
df_percentage = pd.merge(df_count, df_total, on='AppName')
if category != 'App Usage Frequency':
    df_percentage['Percentage'] = (df_percentage['UserCount'] / df_percentage['TotalUsers']) * 100
else:
    df_percentage['Percentage'] = (df_percentage['Count'] / df_percentage['Total']) * 100

# Add total user base by category
df_percentage['TotalUserBase'] = df_percentage.groupby(category)['UserCount' if category != 'App Usage Frequency' else 'Count'].transform('sum')

# Add proportion of total users for each category
df_percentage['Proportion'] = (df_percentage['UserCount' if category != 'App Usage Frequency' else 'Count'] / df_percentage['TotalUserBase']) * 100

# Pivot the data to create a dataframe suitable for a bar chart
df_pivot = df_percentage.pivot(index='AppName', columns=category, values='Percentage').reindex(main_apps)

# Ensure all categories are present in the pivot table
df_pivot = df_pivot.reindex(columns=category_order)

# Sort the DataFrame by the highest value in any column
df_pivot['max'] = df_pivot.max(axis=1)
df_pivot = df_pivot.sort_values(by='max', ascending=False).drop(columns='max').reset_index()

# Melt the pivot dataframe for plotting
df_melted = df_pivot.melt(id_vars='AppName', var_name=category, value_name='Percentage')

# Calculate additional insights for tooltips
df_insights = df_long.groupby(['AppName', category]).size().reset_index(name='Count')
df_insights = df_insights.merge(df_total.rename(columns={'TotalUsers': 'Total'}), on='AppName')
df_insights['Percentage'] = (df_insights['Count'] / df_insights['Total']) * 100

# Add total user base by category
df_insights['TotalUserBase'] = df_insights.groupby(category)['Count'].transform('sum')

# Add proportion of total users for each category
df_insights['Proportion'] = (df_insights['Count'] / df_insights['TotalUserBase']) * 100

# Merge insights with melted dataframe
df_final = pd.merge(df_melted, df_insights, on=['AppName', category], suffixes=('', '_insights'))

# Define color palettes for the categories
diverging_palette = {
    'Not Using': '#ff7f0e',  # Orange
    'Less often': '#fdae6b',  # Light orange
    'Several times a month': '#d9d9d9',  # Gray
    'Several times a week': '#a6cee3',  # Light blue
    'Daily': '#1f78b4',  # Blue
}

sequential_palette = {
    '18-24': '#e5f5e0',  # Light green
    '25-30': '#c7e9c0',  # Light-medium green
    '31-39': '#a1d99b',  # Medium green
    '40-49': '#74c476',  # Dark-medium green
    '50-64': '#41ab5d',  # Dark green
    '65+': '#238b45'  # Very dark green
}

income_palette = {
    'High': '#006d2c',  # Dark green
    'Above Average': '#31a354',  # Dark-medium green
    'Average': '#74c476',  # Medium green
    'Below Average': '#bae4b3',  # Light-medium green
    'Low': '#edf8e9',  # Light green
}

gender_palette = {
    'Male': '#1f77b4',  # Blue
    'Female': '#ff7f0e'  # Pink
}

# Select appropriate color palette based on the category
color_discrete_map = diverging_palette if category == 'App Usage Frequency' else (
    sequential_palette if category == 'Age_group' else (
    income_palette if category == 'Income' else (
    gender_palette if category == 'Gender' else None)))

# Plot the bar chart using Plotly
fig = px.bar(df_final,
             x='AppName', y='Percentage', color=category,
             hover_data={'AppName': False, 'Count': True, 'Total': True, 'Percentage': ':.2f',
                         'TotalUserBase': True, 'Proportion': ':.2f'},
             color_discrete_map=color_discrete_map)

# Add percentage labels inside bars and center them within each category color
fig.update_traces(texttemplate='%{y:.2f}%', textposition='inside', insidetextanchor='middle')

fig.update_layout(
    title=f'App Usage by {category}',
    xaxis_title='App Name',
    yaxis_title='Percentage',
    yaxis=dict(showticklabels=True),  # Show y-axis labels
    legend_title_text=category,
    width=1400,  # Set the width of the plot
    height=800,  # Set the height of the plot
    xaxis={'categoryorder': 'total descending'}  # Sort by highest column
)

# Show the plot in Streamlit
st.plotly_chart(fig, use_container_width=True)
"""

with open("streamlit_app.py", "w") as f:
    f.write(streamlit_app_code)

# Run the Streamlit app
os.system('streamlit run streamlit_app.py --server.port 8501')

# Dorin version with heatmap
import streamlit as st
import pandas as pd
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from pyngrok import ngrok, conf
import os

# Set your ngrok auth token
netta_AUTHTOKEN = "2d7lXbWUAlOidUH3bqltEc1B1PA_2QAyhTGBNYSMybfEcompW"

# Set the ngrok auth token
conf.get_default().auth_token = netta_AUTHTOKEN

# Start ngrok tunnel
http_tunnel = ngrok.connect(8501)
print(f"Streamlit app is running on: {http_tunnel.public_url}")

streamlit_app_code = """
import pandas as pd
import streamlit as st
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt

# Load the CSV file into a DataFrame
file_path = '/content/cleaned_survey_data.csv'
df = pd.read_csv(file_path)

# Streamlit app
st.title('App Usage Analysis and Visualizations')

# Section 1: App Selection
st.header('Select Apps for Analysis')

# Dropdowns for selecting two apps
app_options = ['Facebook', 'Instagram', 'YouTube', 'Twitter']
app1 = st.selectbox('Select first app', app_options)
app2 = st.selectbox('Select second app', app_options)

# Filter dataframe for selected apps
selected_apps = [f'Frequency-{app1}-num', f'Frequency-{app2}-num']

# Section 2: Scatter Plots
st.header(f'Scatter Plots of Age vs Income with Frequency for {app1} and {app2}')

# Scatter plot for the first app
fig_app1 = px.scatter(
    df,
    x='Age_group-num',
    y='Income-num',
    size=selected_apps[0],
    title=f'{app1} Usage',
    labels={selected_apps[0]: f'{app1} Frequency'}
)

# Scatter plot for the second app
fig_app2 = px.scatter(
    df,
    x='Age_group-num',
    y='Income-num',
    size=selected_apps[1],
    title=f'{app2} Usage',
    labels={selected_apps[1]: f'{app2} Frequency'}
)

# Display both plots side by side
col1, col2 = st.columns(2)
with col1:
    st.plotly_chart(fig_app1)
with col2:
    st.plotly_chart(fig_app2)

# Section 3: App Usage Analysis
st.header('App Usage Analysis')

# Binary replacement dictionary
binary = {
    'Using': 1,
    'Not Using': 0,
}

# Apply the replacement to the selected columns
columns_to_rename = [col for col in df.columns if col.startswith('B-')]
for col in columns_to_rename:
    df[col] = df[col].replace(binary)

# Select category for analysis
category = st.selectbox('Select a Category', ['Age_group', 'Gender', 'Income', 'App Usage Frequency', 'Religion', 'Area'])

# Extract relevant columns for the selected category
if category == 'Age_group':
    category_order = ['18-24', '25-30', '31-39', '40-49', '50-64', '65+']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'App Usage Frequency':
    frequency_columns = [col for col in df.columns if col.startswith('Frequency-')]
    df_long_freq = pd.melt(df, id_vars=['Gender', 'Income', 'Religion', 'Area'], value_vars=frequency_columns,
                           var_name='AppName', value_name='Frequency')
    df_long_freq['AppName'] = df_long_freq['AppName'].str.replace('Frequency-', '')
    main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
    df_long_freq = df_long_freq[df_long_freq['AppName'].isin(main_apps)]
    df_long_freq = df_long_freq.rename(columns={'Frequency': category})
    df = df_long_freq
    category_order = ['Not Using', 'Less often', 'Several times a month', 'Several times a week', 'Daily']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'Religion' or category == 'Area':
    category_order = df[category].unique()
else:
    category_order = df[category].unique()

# Transform the dataset to a long format
if category != 'App Usage Frequency':
    df_long = pd.melt(df, id_vars=[category], value_vars=columns_to_rename,
                      var_name='AppName', value_name='Usage')
    df_long = df_long[df_long['Usage'] == 1]  # Filter only those who are using the app
else:
    df_long = df.copy()

# Clean the 'AppName' column
df_long['AppName'] = df_long['AppName'].str.replace('B-', '')

# Filter to include only main applications
main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
df_long = df_long[df_long['AppName'].isin(main_apps)]

# Filter to include only selected apps
df_long = df_long[df_long['AppName'].isin([app1, app2])]

# Calculate the count of users for each app and category
if category != 'App Usage Frequency':
    df_count = df_long.groupby(['AppName', category]).size().reset_index(name='UserCount')
    df_total = df_long.groupby('AppName').size().reset_index(name='TotalUsers')
else:
    df_count = df_long.groupby([category, 'AppName']).size().reset_index(name='Count')
    df_total = df_long.groupby('AppName').size().reset_index(name='Total')

# Merge count and total dataframes
df_percentage = pd.merge(df_count, df_total, on='AppName')
if category != 'App Usage Frequency':
    df_percentage['Percentage'] = (df_percentage['UserCount'] / df_percentage['TotalUsers']) * 100
else:
    df_percentage['Percentage'] = (df_percentage['Count'] / df_percentage['Total']) * 100

# Add total user base by category
df_percentage['TotalUserBase'] = df_percentage.groupby(category)['UserCount' if category != 'App Usage Frequency' else 'Count'].transform('sum')

# Add proportion of total users for each category
df_percentage['Proportion'] = (df_percentage['UserCount' if category != 'App Usage Frequency' else 'Count'] / df_percentage['TotalUserBase']) * 100

# Pivot the data to create a dataframe suitable for a bar chart
df_pivot = df_percentage.pivot(index='AppName', columns=category, values='Percentage').reindex([app1, app2])

# Sort the DataFrame by the highest value in any column
df_pivot['max'] = df_pivot.max(axis=1)
df_pivot = df_pivot.sort_values(by='max', ascending=False).drop(columns='max').reset_index()

# Melt the pivot dataframe for plotting
df_melted = df_pivot.melt(id_vars='AppName', var_name=category, value_name='Percentage')

# Calculate additional insights for tooltips
df_insights = df_long.groupby(['AppName', category]).size().reset_index(name='Count')
df_insights = df_insights.merge(df_total.rename(columns={'TotalUsers': 'Total'}), on='AppName')
df_insights['Percentage'] = (df_insights['Count'] / df_insights['Total']) * 100

# Add total user base by category
df_insights['TotalUserBase'] = df_insights.groupby(category)['Count'].transform('sum')

# Add proportion of total users for each category
df_insights['Proportion'] = (df_insights['Count'] / df_insights['TotalUserBase']) * 100

# Merge insights with melted dataframe
df_final = pd.merge(df_melted, df_insights, on=['AppName', category], suffixes=('', '_insights'))

# Define color palettes for the categories
diverging_palette = {
    'Not Using': '#ff7f0e',  # Orange
    'Less often': '#fdae6b',  # Light orange
    'Several times a month': '#d9d9d9',  # Gray
    'Several times a week': '#a6cee3',  # Light blue
    'Daily': '#1f78b4',  # Blue
}

sequential_palette = {
    '18-24': '#e5f5e0',  # Light green
    '25-30': '#c7e9c0',  # Light-medium green
    '31-39': '#a1d99b',  # Medium green
    '40-49': '#74c476',  # Dark-medium green
    '50-64': '#41ab5d',  # Dark green
    '65+': '#238b45'
# '65+': '#238b45'  # Very dark green
}
income_palette = {
    'Similar to Average': '#edf8e9',  # Light green
    'Other Responses': '#bae4b3',  # Light-medium green
    'Above Average': '#74c476',  # Medium green
    'Way Above Average': '#31a354',  # Dark-medium green
    'below Average': '#006d2c',  # Dark green
    'Way below Average': '#238b45'  # Very dark green
}

gender_palette = {
    'Male': '#1f77b4',  # Blue
    'Female': '#ff7f0e'  # Orange
}

religion_palette = {
    'Jewish - Traditional': '#e41a1c',  # Red
    'Jewish - Secular': '#377eb8',  # Blue
    'Jewish - National Religious': '#4daf4a',  # Green
    'Jewish - Orthodox': '#984ea3',  # Purple
    'Muslim': '#ff7f00'  # Orange
}

area_palette = {
    'Urban': '#8dd3c7',  # Teal
    'Suburban': '#ffffb3',  # Yellow
    'Rural': '#bebada'  # Purple
}

# Select appropriate color palette based on the category
color_discrete_map = diverging_palette if category == 'App Usage Frequency' else (
    sequential_palette if category == 'Age_group' else (
    income_palette if category == 'Income' else (
    gender_palette if category == 'Gender' else (
    religion_palette if category == 'Religion' else (
    area_palette if category == 'Area' else None)))))

# Plot the bar chart using Plotly
fig = px.bar(df_final,
             x='AppName', y='Percentage', color=category,
             hover_data={'AppName': False, 'Count': True, 'Total': True, 'Percentage': ':.2f',
                         'TotalUserBase': True, 'Proportion': ':.2f'},
             color_discrete_map=color_discrete_map)

# Add percentage labels inside bars and center them within each category color
fig.update_traces(texttemplate='%{y:.2f}%', textposition='inside', insidetextanchor='middle')

fig.update_layout(
    title=f'App Usage by {category}',
    xaxis_title='App Name',
    yaxis_title='Percentage',
    yaxis=dict(showticklabels=True),  # Show y-axis labels
    legend_title_text=category,
    width=1400,  # Set the width of the plot
    height=800,  # Set the height of the plot
    xaxis={'categoryorder': 'total descending'}  # Sort by highest column
)

# Show the plot in Streamlit
st.plotly_chart(fig, use_container_width=True)

# Section 4: Heatmaps for App Usage by Religion
st.header('Heatmaps for App Usage by Religion')

# Select binary columns for heatmap
binary_columns = [col for col in df.columns if col.startswith('B-')]
binary_columns = [col for col in binary_columns if col.endswith((app1, app2))]

# Add validation to ensure there are enough binary columns
if len(binary_columns) < 2:
    st.error(f"Not enough binary columns found for the selected apps: {app1} and {app2}")
else:
    # Plot heatmaps for each selected app
    col1, col2 = st.columns(2)

    # Heatmap for the first app
    heatmap_data_app1 = pd.crosstab(df['Religion'], df[binary_columns[0]])
    fig1, ax1 = plt.subplots(figsize=(8, 6))
    sns.heatmap(heatmap_data_app1, annot=True, cmap='coolwarm', ax=ax1)
    ax1.set_title(f'Heatmap for {app1} Usage by Religion')

    # Heatmap for the second app
    heatmap_data_app2 = pd.crosstab(df['Religion'], df[binary_columns[1]])
    fig2, ax2 = plt.subplots(figsize=(8, 6))
    sns.heatmap(heatmap_data_app2, annot=True, cmap='coolwarm', ax=ax2)
    ax2.set_title(f'Heatmap for {app2} Usage by Religion')

    with col1:
        st.pyplot(fig1)
    with col2:
        st.pyplot(fig2)
"""

with open("streamlit_app.py", "w") as f:
    f.write(streamlit_app_code)

# Run the Streamlit app
os.system('streamlit run streamlit_app.py --server.port 8501')

# best so far!
import os
from pyngrok import ngrok, conf

# Set your ngrok auth token
netta_AUTHTOKEN = "2d7lXbWUAlOidUH3bqltEc1B1PA_2QAyhTGBNYSMybfEcompW"

# Set the ngrok auth token
conf.get_default().auth_token = netta_AUTHTOKEN

# Start ngrok tunnel
http_tunnel = ngrok.connect(8501)
print(f"Streamlit app is running on: {http_tunnel.public_url}")

# Write the updated Streamlit app code with the visualization
streamlit_app_code = """
import pandas as pd
import streamlit as st
import plotly.express as px

# Load the CSV file into a DataFrame
file_path = 'cleaned_survey_data.csv'
df = pd.read_csv(file_path)

# Binary replacement dictionary
binary = {
    'Using': 1,
    'Not Using': 0,
}

# Apply the replacement to the selected columns
columns_to_rename = [col for col in df.columns if col.startswith('B-')]
for col in columns_to_rename:
    df[col] = df[col].replace(binary)

# Streamlit app
st.title('App Usage Analysis')

# Select category for analysis
category = st.selectbox('Select a Category', ['Age_group', 'Gender', 'Income', 'App Usage Frequency', 'Religion', 'Area'])

# Extract relevant columns for the selected category
if category == 'Age_group':
    category_order = ['18-24', '25-30', '31-39', '40-49', '50-64', '65+']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'App Usage Frequency':
    frequency_columns = [col for col in df.columns if col.startswith('Frequency-')]
    df_long_freq = pd.melt(df, id_vars=['Gender', 'Income', 'Religion', 'Area'], value_vars=frequency_columns,
                           var_name='AppName', value_name='Frequency')
    df_long_freq['AppName'] = df_long_freq['AppName'].str.replace('Frequency-', '')
    main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
    df_long_freq = df_long_freq[df_long_freq['AppName'].isin(main_apps)]
    df_long_freq = df_long_freq.rename(columns={'Frequency': category})
    df = df_long_freq
    category_order = ['Not Using', 'Less often', 'Several times a month', 'Several times a week', 'Daily']
    df[category] = pd.Categorical(df[category], categories=category_order, ordered=True)
elif category == 'Religion' or category == 'Area':
    category_order = df[category].unique()
else:
    category_order = df[category].unique()

# Transform the dataset to a long format
if category != 'App Usage Frequency':
    df_long = pd.melt(df, id_vars=[category], value_vars=columns_to_rename,
                      var_name='AppName', value_name='Usage')
    df_long = df_long[df_long['Usage'] == 1]  # Filter only those who are using the app
else:
    df_long = df.copy()

# Clean the 'AppName' column
df_long['AppName'] = df_long['AppName'].str.replace('B-', '')

# Filter to include only main applications
main_apps = ['Facebook', 'YouTube', 'Instagram', 'TikTok', 'Twitter', 'LinkedIn', 'WhatsApp']
df_long = df_long[df_long['AppName'].isin(main_apps)]

# Calculate the count of users for each app and category
if category != 'App Usage Frequency':
    df_count = df_long.groupby(['AppName', category]).size().reset_index(name='UserCount')
    df_total = df_long.groupby('AppName').size().reset_index(name='TotalUsers')
else:
    df_count = df_long.groupby([category, 'AppName']).size().reset_index(name='Count')
    df_total = df_long.groupby('AppName').size().reset_index(name='Total')

# Merge count and total dataframes
df_percentage = pd.merge(df_count, df_total, on='AppName')
if category != 'App Usage Frequency':
    df_percentage['Percentage'] = (df_percentage['UserCount'] / df_percentage['TotalUsers']) * 100
else:
    df_percentage['Percentage'] = (df_percentage['Count'] / df_percentage['Total']) * 100

# Add total user base by category
df_percentage['TotalUserBase'] = df_percentage.groupby(category)['UserCount' if category != 'App Usage Frequency' else 'Count'].transform('sum')

# Add proportion of total users for each category
df_percentage['Proportion'] = (df_percentage['UserCount' if category != 'App Usage Frequency' else 'Count'] / df_percentage['TotalUserBase']) * 100

# Pivot the data to create a dataframe suitable for a bar chart
df_pivot = df_percentage.pivot(index='AppName', columns=category, values='Percentage').reindex(main_apps)

# Sort the DataFrame by the highest value in any column
df_pivot['max'] = df_pivot.max(axis=1)
df_pivot = df_pivot.sort_values(by='max', ascending=False).drop(columns='max').reset_index()

# Melt the pivot dataframe for plotting
df_melted = df_pivot.melt(id_vars='AppName', var_name=category, value_name='Percentage')

# Calculate additional insights for tooltips
df_insights = df_long.groupby(['AppName', category]).size().reset_index(name='Count')
df_insights = df_insights.merge(df_total.rename(columns={'TotalUsers': 'Total'}), on='AppName')
df_insights['Percentage'] = (df_insights['Count'] / df_insights['Total']) * 100

# Add total user base by category
df_insights['TotalUserBase'] = df_insights.groupby(category)['Count'].transform('sum')

# Add proportion of total users for each category
df_insights['Proportion'] = (df_insights['Count'] / df_insights['TotalUserBase']) * 100

# Merge insights with melted dataframe
df_final = pd.merge(df_melted, df_insights, on=['AppName', category], suffixes=('', '_insights'))

# Define color palettes for the categories
diverging_palette = {
    'Not Using': '#ff7f0e',  # Orange
    'Less often': '#fdae6b',  # Light orange
    'Several times a month': '#d9d9d9',  # Gray
    'Several times a week': '#a6cee3',  # Light blue
    'Daily': '#1f78b4',  # Blue
}

sequential_palette = {
    '18-24': '#e5f5e0',  # Light green
    '25-30': '#c7e9c0',  # Light-medium green
    '31-39': '#a1d99b',  # Medium green
    '40-49': '#74c476',  # Dark-medium green
    '50-64': '#41ab5d',  # Dark green
    '65+': '#238b45'  # Very dark green
}
income_palette = {
    'Low': '#edf8e9',  # Light green
    'Below Average': '#bae4b3',  # Light-medium green
    'Average': '#74c476',  # Medium green
    'Above Average': '#31a354',  # Dark-medium green
    'High': '#006d2c'  # Dark green
}

gender_palette = {
    'Male': '#1f77b4',  # Blue
    'Female': '#ff7f0e'  # Pink
}

religion_palette = {
    'Religion1': '#e41a1c',  # Red
    'Religion2': '#377eb8',  # Blue
    'Religion3': '#4daf4a',  # Green
    'Religion4': '#984ea3',  # Purple
    'Religion5': '#ff7f00'  # Orange
}

area_palette = {
    'Urban': '#8dd3c7',  # Teal
    'Suburban': '#ffffb3',  # Yellow
    'Rural': '#bebada'  # Purple
}

# Select appropriate color palette based on the category
color_discrete_map = diverging_palette if category == 'App Usage Frequency' else (
    sequential_palette if category == 'Age_group' else (
    income_palette if category == 'Income' else (
    gender_palette if category == 'Gender' else (
    religion_palette if category == 'Religion' else (
    area_palette if category == 'Area' else None)))))

# Plot the bar chart using Plotly
fig = px.bar(df_final,
             x='AppName', y='Percentage', color=category,
             hover_data={'AppName': False, 'Count': True, 'Total': True, 'Percentage': ':.2f',
                         'TotalUserBase': True, 'Proportion': ':.2f'},
             color_discrete_map=color_discrete_map)

# Add percentage labels inside bars and center them within each category color
fig.update_traces(texttemplate='%{y:.2f}%', textposition='inside', insidetextanchor='middle')

fig.update_layout(
    title=f'App Usage by {category}',
    xaxis_title='App Name',
    yaxis_title='Percentage',
    yaxis=dict(showticklabels=True),  # Show y-axis labels
    legend_title_text=category,
    width=1400,  # Set the width of the plot
    height=800,  # Set the height of the plot
    xaxis={'categoryorder': 'total descending'}  # Sort by highest column
)

# Show the plot in Streamlit
st.plotly_chart(fig, use_container_width=True)
"""

with open("streamlit_app.py", "w") as f:
    f.write(streamlit_app_code)

# Run the Streamlit app
os.system('streamlit run streamlit_app.py --server.port 8501')
